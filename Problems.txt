'''

 Question : 

 /*
Formation is trying to assign a group of Fellows algorithms of varying difficulty levels. The algorithm difficulty should feel fair to all Fellows based on each Fellow's algorithmic skill level.

We are given an array of integers representing the skill level of each Fellow and we are asked to return an array of integers representing the difficulty of an algorithm to assign each Fellow respectively.

The minimum difficulty is 1. 
When a Fellow  has a higher skill level than an adjacent Fellow they must be given a more difficult problem than their neighbor. 
Return the array of difficulties representing the minimum difficulty we can give each Fellow.
 

EXAMPLE(S)
fellows = [10, 20, 60, 70, 50, 10, 20]
print(assignAlgorithms(fellows) == [1,2,3,4,2,1,2])

Explanation:
After the left-to-right pass:
[1, 2, 3, 4, 1, 1, 2]

we are just comparing if ith value is greater than (i-1)th

-baseline difficulty is 1 
-this takes care of difficulty due to left neighbor for any i 



Now, the right-to-left pass:
[1, 2, 3, max(4, 3) = 4, max(1,2) = 2, 1, max(2, 1) = 2]

The last element doesn't get replaced because the existing value (2) is larger than the right-to-left value (1).

- this takes care of difficulty due to right neighbor for any i 

- think of two arrays : 

1. maxDifficultyDueToLeftNeigbor 
2. maxDifficultyDueToRightNeigbor 
3. results -> use maxDifficultyDueToLeftNeigbor and maxDifficultyDueToRightNeigbor arrays to create results 


Finally, the algorithm difficulties are:
[1, 2, 3, 4, 2, 1, 2]
 

Edge cases/Assumptions/Observations : 
- what happens when we encounter an adjacent Fellow with the same skill level? (assumption: problem stays at the same difficulty level)
- why is a max(1, x) comparison needed for the last element if the minimum difficulty is already 1?


Approach : 

Input: skills levels of fellows [x1,x2,x3,x4,x5]
Output: list of difficulty levels for each fellow [y1,y2,y3,y4,y5]

Result array [size of the input array] set them all to 1 

First pass:
    starting at the 1st position
    comparing with the left neighbor
        if the skill level is greater than the left neighbor, 
            update the difficulty level as left+1
        if not, don't need to do anything


Second pass:
    starting at the last position
    comparing with the right neighbor
        updating the difficulty level to be the max of itself and the right+1 
    
Follow up :
https://leetcode.com/problems/gas-station/ 
https://leetcode.com/problems/jump-game/

Candies distribution 
 
   
FUNCTION SIGNATURE
def assignAlgorithms(fellows):

'''

#Python code

# Johnny
# time - O(n) n is number of fellows
# space - O(n) n is number of fellows
def assignAlgorithmsJohnny(fellows):
    result = [1] * len(fellows)
    
    for i in range(1, len(fellows)):
        if fellows[i] > fellows[i - 1]:
            result[i] = result[i - 1] + 1
        if fellows[i] == fellows[i - 1]:
            result[i] = result[i - 1]
    
    for i in range(len(fellows) - 2, -1, -1):
        if fellows[i] > fellows[i + 1]:
            result[i] = max(result[i], result[i + 1] + 1)
        
    return result




'''
Seb

'''
def assignAlgorithms(fellows):
    last_fellow = fellows[0]
    output = [1] * len(fellows)
    difficulty = 1
    
    for i in range(len(fellows)):
        if fellows[i] < last_fellow:
            difficulty = 1
        elif fellows[i] >last_fellow:
            difficulty += 1
        output[i] = difficulty
        last_fellow = fellows[i] 
    difficulty = 1
    for i in range(len(fellows) - 1, -1, -1):
        if fellows[i] < last_fellow:
            difficulty = 1
        elif fellows[i] >last_fellow:
            difficulty += 1
        output[i] = max(output[i], difficulty)
        difficulty = output[i]
        last_fellow = fellows[i]
    return output









#JavaScript code 

'''

Sonmi
function assignAlgorithms(fellows) {
    let result = Array(fellows.length).fill(1) // initializing an array filled with 1
    for (let i = 1; i < fellows.length; i++) {
        if(fellows[i] > fellows[i-1]) {
            result[i] = result[i-1] + 1
        }
    }

    //second pass
    # comparing with the right neighbor
    #     updating the difficulty level to be the max of itself and the right+1 
    for (let i = result.length-2 ; i >=0 ; i--) {

        //start the loop from result.length-2, check if fellows[i]>fellows[i+1] 
        
        if(result[i] >result[i+1] ) {
           result[i] = Math.max(result[i], result[i+1] + 1)
        }
}
    return result
}

'''











#Rohan
'''
function assignAlgorithms(fellows) {
    
    if(fellows.length === 0) {
        return []
    }

    let result = []
    let difficultyLvl = 0;
    
    for(let i=0; i<fellows.length-1; i++){
        
       }

    for(let i=fellow)
    
}









'''
#Michael - BUGS EXIST

# const assignAlgorithms = (fellows) => {

#   let result = Array(fellows.length).fill(1)

#   // first pass
#   for(let i = 0; i < fellows.length; i++) {
#     if(fellows[i] > fellows[i-1]) {
#       result[i] = result[i-1] + 1
#     }
#   }

#   // second pass
#   for(let j = fellows.length - 2; j >= 0; j--) {
#     if(fellows[j] > fellows[j+1]) {
#       result[j] = Math.max(result[j], result[j+1]+1)
#     }
    
#   }
  
#   return result
# }







# Rayshawn
# Time: o(n) - need to visit all the values in the array
# Space: o(n) - output array will be as big as the input
def assignAlgorithms(fellows):
    # make result array with value of 1s
    result = [1] * len(fellows)
    
    # fist pass 
    for i in range(1, len(fellows)):
        if fellows[i] > fellows[i - 1]:
            result[i] = result[i - 1] + 1
    
    # second pass - this should work, could also use >
    for i in reversed(range(len(fellows))):
        if fellows[i] != fellows[i + 1]:
            result[i] = max(result[i], result[i + 1] + 1)
    
    # return the result
    return result 

# print(assignAlgorithms([10, 20, 60, 70, 50, 10, 20]))







